{
	// Place your snippets for go here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Algorithm boilerplate": {
		"prefix": "albp",
		"body": [
			"package main",
			"",
			"import (",
			"\t\"bufio\"",
			"\t\"fmt\"",
			"\t\"io\"",
			"\t\"os\"",
			"\t\"strconv\"",
			"\t\"strings\"",
			")",
			"",
			"func start() {",
			"\tvar t int",
			"\tmustReadLineOfInts(&t)",
			"\tfor i := 0; i < t; i++ {",
			"\t\ttest()",
			"\t}",
			"}",
			"",
			"func test() {",
			"\t$1",
			"}",
			"",
			"/*********Start boilerplate***********/",
			"",
			"var stdin *bufio.Reader",
			"var stdout *bufio.Writer",
			"",
			"func main() {",
			"\treadFrom := os.Stdin",
			"\tif len(os.Args) == 2 {",
			"\t\tvar err error",
			"\t\treadFrom, err = os.Open(os.Args[1])",
			"\t\tif err != nil {",
			"\t\t\tpanic(err)",
			"\t\t}",
			"\t}",
			"\tif len(os.Args) > 2 {",
			"\t\tpanic(\"Too much arguments.\")",
			"\t}",
			"\tstdin = bufio.NewReader(readFrom)",
			"\tstdout = bufio.NewWriter(os.Stdout)",
			"\tdefer stdout.Flush()",
			"\tstart()",
			"}",
			"",
			"func mustReadLine() string {",
			"\tstr, err := stdin.ReadString('\\n')",
			"\tif err != nil && err != io.EOF {",
			"\t\tpanic(err)",
			"\t}",
			"\tstr = strings.TrimRight(str, \"\\n\")",
			"\treturn str",
			"}",
			"",
			"func mustAtoi(in string) int {",
			"\ti, err := strconv.Atoi(in)",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn i",
			"}",
			"",
			"func debug(str string) {",
			"\tstdout.Flush()",
			"\tos.Stderr.WriteString(\"[debug] \" + str + \"\\n\")",
			"}",
			"",
			"func mustReadLineOfInts(a ...*int) {",
			"\tline := mustReadLine()",
			"\tstrs := strings.Split(line, \" \")",
			"\tif len(strs) != len(a) {",
			"\t\tpanic(\"Expected \" + strconv.Itoa(len(a)) + \" numbers, got \" + strconv.Itoa(len(strs)) + \".\")",
			"\t}",
			"\tfor i := 0; i < len(a); i++ {",
			"\t\t(*a[i]) = mustAtoi(strs[i])",
			"\t}",
			"}",
			"",
			"func mustReadLineOfIntsIntoArray() []int {",
			"\tline := mustReadLine()",
			"\tstrs := strings.Split(line, \" \")",
			"\tres := make([]int, len(strs))",
			"\tfor i := 0; i < len(strs); i++ {",
			"\t\tres[i] = mustAtoi(strs[i])",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func assert(t bool) {",
			"\tif !t {",
			"\t\tpanic(\"Assertion failed.\")",
			"\t}",
			"}",
			""
		]
	},
	"Codejam": {
		"prefix": "cj",
		"body": [
			"package main",
			"",
			"import (",
			"\t\"bufio\"",
			"\t\"fmt\"",
			"\t\"io\"",
			"\t\"os\"",
			"\t\"strconv\"",
			"\t\"strings\"",
			")",
			"",
			"func start() {",
			"\tvar t int",
			"\tmustReadLineOfInts(&t)",
			"\tfor i := 0; i < t; i++ {",
			"\t\tfmt.Fprintf(stdout, \"Case #%d: \", i+1)",
			"\t\ttest()",
			"\t}",
			"}",
			"",
			"func test() {",
			"\t$1",
			"}",
			"",
			"/*********Start boilerplate***********/",
			"",
			"var stdin *bufio.Reader",
			"var stdout *bufio.Writer",
			"",
			"func main() {",
			"\treadFrom := os.Stdin",
			"\tif len(os.Args) == 2 {",
			"\t\tvar err error",
			"\t\treadFrom, err = os.Open(os.Args[1])",
			"\t\tif err != nil {",
			"\t\t\tpanic(err)",
			"\t\t}",
			"\t}",
			"\tif len(os.Args) > 2 {",
			"\t\tpanic(\"Too much arguments.\")",
			"\t}",
			"\tstdin = bufio.NewReader(readFrom)",
			"\tstdout = bufio.NewWriter(os.Stdout)",
			"\tdefer stdout.Flush()",
			"\tstart()",
			"}",
			"",
			"func mustReadLine() string {",
			"\tstr, err := stdin.ReadString('\\n')",
			"\tif err != nil && err != io.EOF {",
			"\t\tpanic(err)",
			"\t}",
			"\tstr = strings.TrimRight(str, \"\\n\")",
			"\treturn str",
			"}",
			"",
			"func mustAtoi(in string) int {",
			"\ti, err := strconv.Atoi(in)",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn i",
			"}",
			"",
			"func debug(str string) {",
			"\tstdout.Flush()",
			"\tos.Stderr.WriteString(\"[debug] \" + str + \"\\n\")",
			"}",
			"",
			"func mustReadLineOfInts(a ...*int) {",
			"\tline := mustReadLine()",
			"\tstrs := strings.Split(line, \" \")",
			"\tif len(strs) != len(a) {",
			"\t\tpanic(\"Expected \" + strconv.Itoa(len(a)) + \" numbers, got \" + strconv.Itoa(len(strs)) + \".\")",
			"\t}",
			"\tfor i := 0; i < len(a); i++ {",
			"\t\t(*a[i]) = mustAtoi(strs[i])",
			"\t}",
			"}",
			"",
			"func mustReadLineOfIntsIntoArray() []int {",
			"\tline := mustReadLine()",
			"\tstrs := strings.Split(line, \" \")",
			"\tres := make([]int, len(strs))",
			"\tfor i := 0; i < len(strs); i++ {",
			"\t\tres[i] = mustAtoi(strs[i])",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func assert(t bool) {",
			"\tif !t {",
			"\t\tpanic(\"Assertion failed.\")",
			"\t}",
			"}",
			""
		]
	},
	"Automatic tester": {
		"prefix": "att",
		"body": [
			"package main",
			"",
			"import (",
			"\t\"bufio\"",
			"\t\"fmt\"",
			"\t\"io\"",
			"\t\"os\"",
			"\t\"os/exec\"",
			"\t\"strings\"",
			"\t\"syscall\"",
			")",
			"",
			"type WrappedReader struct {",
			"\tr      *bufio.Reader",
			"\tstdout io.Writer",
			"}",
			"type WrappedWriter struct {",
			"\tw         io.Writer",
			"\tstdout    io.Writer",
			"\toutBuffer *bufio.Writer",
			"}",
			"",
			"func (wr *WrappedReader) ReadLine() string {",
			"\tline, err := wr.r.ReadString('\\n')",
			"\tif err != nil && err != io.EOF {",
			"\t\tpanic(err)",
			"\t}",
			"\tline = strings.TrimRight(line, \"\\n\")",
			"\tfmt.Fprintf(wr.stdout, \"< %s\\n\", line)",
			"\treturn line",
			"}",
			"",
			"func (ww *WrappedWriter) Write(p []byte) (n int, err error) {",
			"\tn, err = ww.w.Write(p)",
			"\tif err != nil {",
			"\t\tif err == io.ErrClosedPipe {",
			"\t\t\terr = nil",
			"\t\t\treturn",
			"\t\t}",
			"\t\tpanic(err)",
			"\t}",
			"\tif ww.outBuffer == nil {",
			"\t\tww.outBuffer = bufio.NewWriterSize(ww.stdout, 10000)",
			"\t\tww.outBuffer.WriteString(\"> \")",
			"\t}",
			"\tfor _, b := range p[:n] {",
			"\t\tif b == '\\n' {",
			"\t\t\tww.outBuffer.WriteByte('\\n')",
			"\t\t\tww.outBuffer.Flush()",
			"\t\t\tww.outBuffer.WriteString(\"> \")",
			"\t\t} else {",
			"\t\t\tww.outBuffer.WriteByte(b)",
			"\t\t}",
			"\t}",
			"\treturn",
			"}",
			"",
			"func main() {",
			"\tif len(os.Args) != 2 {",
			"\t\tfmt.Fprintf(os.Stderr, \"Expected name of program as the only argument, got %d arguments instead.\", len(os.Args))",
			"\t\tos.Exit(1)",
			"\t}",
			"\tstdout := bufio.NewWriter(os.Stdout)",
			"\tcmd := exec.Command(os.Args[1])",
			"\tin, err := cmd.StdinPipe()",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\trawout, err := cmd.StdoutPipe()",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\tout := bufio.NewReader(rawout)",
			"\tcmd.Start()",
			"\tt := 1",
			"\tsuccess := true",
			"\tww := WrappedWriter{w: in, stdout: stdout}",
			"\twr := WrappedReader{r: out, stdout: stdout}",
			"\tfmt.Fprintf(&ww, \"%d\\n\", t)",
			"\tfor i := 0; i < t; i++ {",
			"\t\tvar res bool",
			"\t\t(func() {",
			"\t\t\tdefer func() {",
			"\t\t\t\tp := recover()",
			"\t\t\t\tif p != nil {",
			"\t\t\t\t\tres = false",
			"\t\t\t\t}",
			"\t\t\t}()",
			"\t\t\tres = test(&ww, &wr)",
			"\t\t})()",
			"\t\tif !res || !success {",
			"\t\t\tsuccess = false",
			"\t\t\tbreak",
			"\t\t}",
			"\t}",
			"\tin.Close()",
			"\tif ww.outBuffer.Buffered() > 2 {",
			"\t\tww.outBuffer.Flush()",
			"\t}",
			"\tif !success {",
			"\t\tfmt.Fprintf(stdout, \"Errored.\\n\")",
			"\t}",
			"\tstdout.Flush()",
			"\tcmd.Process.Signal(syscall.SIGINT)",
			"\tcmd.Process.Wait()",
			"\tif !success {",
			"\t\tos.Exit(1)",
			"\t}",
			"}",
			"",
			"func assert(b bool) {",
			"\tif !b {",
			"\t\tpanic(\"Assertion failed.\")",
			"\t}",
			"}",
			"",
			"func test(in *WrappedWriter, out *WrappedReader) bool {",
			"\tline := out.ReadLine()",
			"\tassert(line == \"1\")",
			"\t$1",
			"\treturn true",
			"}",
			""
		]
	}
}
