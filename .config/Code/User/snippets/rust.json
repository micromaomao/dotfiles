{
	// Place your snippets for rust here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Bolierplate": {
		"prefix": "albp",
		"body": [
			"use std::env;",
			"use std::fs;",
			"use std::io;",
			"use std::str;",
			"",
			"fn start(p: &mut Prog) {",
			"  p.print_debug_log = true;",
			"  let nums: Vec<u32> = p.read_line_of(2);",
			"  p.debug(&format!(\"{} and {} received.\", nums[0], nums[1]));",
			"  $1",
			"}",
			"",
			"struct Prog<'a> {",
			"  read_from: Box<dyn io::BufRead + 'a>,",
			"  print_debug_log: bool,",
			"}",
			"",
			"impl<'a> Prog<'a> {",
			"  fn new(stdin_locked: io::StdinLock<'a>) -> Prog<'a> {",
			"    let args: Vec<String> = env::args().collect();",
			"    if args.len() == 1 {",
			"      return Prog::<'a> {",
			"        read_from: Box::new(stdin_locked),",
			"        print_debug_log: false,",
			"      };",
			"    } else if args.len() == 2 {",
			"      let file_name = &args[1];",
			"      match fs::File::open(file_name) {",
			"        Ok(file) => {",
			"          return Prog {",
			"            read_from: Box::new(io::BufReader::new(file)),",
			"            print_debug_log: true,",
			"          };",
			"        }",
			"        Err(e) => {",
			"          eprintln!(\"\\x1b[31;1mError opening file {}: {}\\x1b[0m\", file_name, e);",
			"          panic!();",
			"        }",
			"      }",
			"    } else {",
			"      panic!(\"\");",
			"    }",
			"  }",
			"",
			"  fn read_line(&mut self) -> String {",
			"    let mut str = String::new();",
			"    if let Result::Err(e) = self.read_from.read_line(&mut str) {",
			"      panic!(\"Failed to read: {}\", e);",
			"    }",
			"    return str;",
			"  }",
			"",
			"  fn read_line_of<I: str::FromStr>(&mut self, length_assert: usize) -> Vec<I> {",
			"    let str = &self.read_line();",
			"    let str = str.trim();",
			"    let mut vec = Vec::<I>::new();",
			"    let mut index: usize = 0;",
			"    for substr in str.split_whitespace() {",
			"      let parse_result: Result<I, _> = substr.parse();",
			"      match parse_result {",
			"        Ok(stuff) => vec.push(stuff),",
			"        Err(_) => {",
			"          eprintln!(\"\\x1b[31mOn parsing line:\\n{}\\x1b[0m\", str);",
			"          eprintln!(\"{}^\", \" \".repeat(index));",
			"          panic!(\"Parsing {:#?} errored.\", substr);",
			"        }",
			"      };",
			"      index += substr.len();",
			"      index += 1;",
			"    }",
			"    if vec.len() != length_assert {",
			"      panic!(\"Expected {} inputs, got {}.\", length_assert, vec.len());",
			"    }",
			"    vec",
			"  }",
			"",
			"  fn debug(&self, out: &str) {",
			"    if self.print_debug_log {",
			"      eprintln!(\"\\x1b[33m{}\\x1b[0m\", out);",
			"    }",
			"  }",
			"}",
			"",
			"fn main() {",
			"  let stdin = io::stdin();",
			"  let mut p = Prog::new(stdin.lock());",
			"  start(&mut p);",
			"}",
			""
		]
	}
}
